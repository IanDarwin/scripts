#!/bin/ksh -f

# Rearrange Pictures to strict date-order filing by moving into directory with yyyy/mm/dd

# Can NOT use exiv2 "--rename fmt" because that has only one-second resolution,
# and since about 2000 A.D., cameras can take >1 pix per second.

# USE WITH CAUTION! USE AT OWN RISK! Failures may lose pictures - take a backup first

USAGE="$0 [-v] \$PWD/file[...]"

# Sample entry: Image timestamp : 2023:07:28 19:46:53
# Sample entry: Exif.Image.DateTime Ascii 20  2023:07:09 13:02:10
# Note that in both, $4 is the yyyy:mm:dd that we use in awk below.

function usage {		# give usage message, and exit
	echo "Usage: ${USAGE}" 2>&1
	exit 1
}

# Make sure we are in right folder
cd ~/Pictures

RUNNER=sh

while getopts "nvx" opt
do
	case "$opt" in
		n)	RUNNER=cat;;
		v)	VERBOSE=true;;
		x)	RUNNER="ksh -x";;
		*)	usage;;
	esac
done
shift `expr $OPTIND - 1`		 # leave just filenames

# Bomb on first failure, try to avoid losing pix:
set -e

for f in $@
do
  if [ ! -f "$f" ]; then
	echo $0: $f: cannot read file;
	continue;
  fi
  exiv2 -g Date "$f" |      
	awk '
		BEGIN { found = 0 }
		$0 ~ /^Image timestamp : ....:..:../ ||
		$0 ~ /Exif.Image.DateTime/ {
			gsub(":","/",$4)
			printf "if [ ! -d \"%s\" ]; then mkdir -p \"%s\"; fi\n", $4, $4
			base=F; sub(".*/", "", base)
			printf "if [ -f \"%s/%s\" ]; then echo DUPE \"%s/%s\"; else mv \"%s\" \"%s/\"; fi\n", $4, base, $4, F, F, $4
			found = 1
		}
		END { if (!found) {
			print "echo storepixbydate: '$f': no image timestamp, not moving."
		}
	}' F="$f"
done | ${RUNNER}
